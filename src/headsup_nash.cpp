/* 
 * C++20
 *
 * This program computes the Nash Euilibrium Strategy for a two player all
 * in or fold Texas Holdem game given the blinds and stack sizes.
 *
 * To determine the winner of the hand we use the so-called Two-Plus-Two
 * Evaluator. See reference [2]. 
 *
 * The Nash Equilibrium strategy is found through a Regret Minimization
 * algorithm. Also sometimes called Monte Carlo Tree Search. See
 * reference [1].
 *
 * Notes:
 * The Nash Equilibrium is a single strategy but both strategies
 * taken together. It is like a dance.
 *
 * The strategies don't necessarily converge to a Nash Equilibrium.
 * It is the average strategy (averaged over the number of times the
 * decision node was reached which in our case is the number of times
 * the 2 card starter hand was randomly dealt).
 * 
 * Playing a Nash Equilibrium strategy isn't the one that could make you
 * the most money. There could be a better strategy that wins you more
 * money but it could have holes in it that could be exploited; it's a
 * double edged sword. Like in boxing, if you go for the attack, you expose
 * yourself to getting hit.
 *
 * There could be many Nash Equilibriums.
 *
 * The 2 player zero sum game is a special case. In that you could play
 * from any Nash Equilibrum. However, it doesn't generalize to games
 * with more than 2 players. For example, in a 3 player game,
 * 2 players could play from one Nash Equilibrium profile,
 * and if you play a strategy from another Nash Equilibrium profile, you
 * will probably lose. You would need to somehow all be playing from the
 * same Nash Equilibrium. However, this algorithm could work for 3 or more
 * players if you can somehow guess your opponent's strategy.
 * You could then set your opponents' strategies fixed and run
 * this regret matching algorithm to determine the best strategy.
 *
 * 'Index' Representation and 'Specific' Representation
 * We don't care about all (52 choose 2) hands, we can just care if they're
 * unsuited or suited or a pair. i.e. the strategy for the button when
 * dealt say Ac2d is the same for Ah2s. The particular suits don't matter.
 * The strategy for a particular player can be represented on a 13 x 13 grid
 * where one half (split diagonally) represents suited cards and the other
 * half are unsuited cards and the diagonal represents pairs. The row and
 * column number on this chart is what i will call 'the index' representation
 * of a starter hand. A starter hand can be represented as 2 numbers taken
 * from 1 to 52 inclusive where 1 = 2c, 2 = 2d, 3 = 2h, 4 = 2s, 5 = 3c, ...,
 * 48 = Ks, 49 = Ac, 50 = Ad, 51 = Ah, 52 = As. I will call this the
 * 'specific representation' of the starter hand. So a Ace of spades and
 * a 3 of hearts is (7, 52) in the specific representation and (12, 1). Where
 * I will use the convention that if the first number > second number, it
 * represents an unsuited hand and if the first number < second number,
 * it represents a suited hand in the index representation.
 *
 * References:
 * [1] Neller, T., Lanctot, M. An Introduction to Counterfactual Regret
 * Minimization[Computer Science Faculty Publications]. (2013). Retrieved
 * from https://cupola.gettysburg.edu/csfac/19/
 *
 * [2] https://web.archive.org/web/20111103160502/http://www.codingthewheel.com/archives/poker-hand-evaluator-roundup#2p2
 */
#include <iostream>
#include <algorithm>
#include <random>
#include <cstring>
#include <array>
#include <sstream>
#include <fstream>
#include <span>
#include "strategy.h"

// To determine the winner of a hand you need to do
// 7 look ups (using th 5 community cards AKA 'the board'
// and your 2 cards AKA 'your hand' or 'your hole cards'
// This is a large array of integers produced by the
// Two-Plus-Two evaluator.
constexpr size_t HR_SIZE = 32487834;
const std::string HR_FILE = "handranks.dat";
const int NUM_DEFAULT_ITERATIONS = 1000000;
const int NUM_ACTIONS = 2;

// button outcome
enum class Outcome {WIN, LOSE, TIE};
enum class Action {PUSH, FOLD};

// The large array of numbers used to quickly computer the winner of a hand.
// It is global to avoid strange behaviour. It is also capitalized like a
// constant because it doesn't change after being initialized with
// load_handranks() function.
std::array<int, HR_SIZE> HANDRANKS;

void load_handranks(std::string handranks_file);
std::pair<int,int> get_index(std::array<int,2> hand);
int get_handvalue(std::span<int const> cards, int initial=53);


/* Load numbers into the handranks array from a file.
 *
 * @param handranks_file:
 * The file of numbers generated by the handranks evaluator
 */
void load_handranks(std::string handranks_file)
{
  std::cout << "Loading " << handranks_file << " ...";
  memset(&HANDRANKS, 0, std::size(HANDRANKS));

  FILE* fin = fopen(handranks_file.c_str(), "rb");
  if (!fin)
  {
      std::cerr << "error when loading " << handranks_file << std::endl;
      exit(1);
  }

  size_t elementsRead = fread(&HANDRANKS, sizeof(HANDRANKS[0]),
                              std::size(HANDRANKS), fin);
  if (elementsRead != std::size(HANDRANKS))
  {
    std::cerr << "error when reading " << handranks_file << std::endl;
    exit(2);
  }

  fclose(fin);
  std::cout << "Done" << std::endl;
}


/**
 * Get Index representation from Specific Representation of a starter hand.
 *
 * e.g. Since a player's strategy for an unsuited hand is the same no matter
 * the two suits of the hand, we can reduce the number of starter hands from
 * (52 choose 2) = 1326 to 13x13 = 169. Where there are 3 broad categories:
 * pairs, suited, unsuited.
 *
 * @param hand The specific representation.
 * @return The index representation of the hand.
 */
std::pair<int, int> get_index(std::array<int,2> hand)
{
    int v1 = (hand[0] - 1) / 4;
    int v2 = (hand[1] - 1) / 4;
    if (v1 == v2) //check if pocket pair first
        return std::make_pair(v1, v2);
    else
    {
        int s1 = (hand[0] - 1) % 4;
        int s2 = (hand[1] - 1) % 4;
        if (s1 == s2)
            return std::make_pair(std::max(v1, v2), std::min(v1,v2));
        else
            return std::make_pair(std::min(v1,v2), std::max(v1,v2));
    }
}


/**
 * Get the hand value that is used to determine the winner.
 *
 * This is the so called Two-Plus-Two Evaluator.
 *
 * The function can be called to 'precompute' the hand value
 * to speed things up. This precomputed value can be used as the
 * initial_val and you just give it the remaining cards. e.g. if
 * you have 5 board cards. you can precompute for the 5 cards,
 * then for one player you use this precomputed value as initial_val and
 * their 2 cards to get the hand value. For the other player, you use the
 * precomputed value as initial_val and use the other player's two cards
 * to compute their hand value. This saves you from computing the value
 * for the board twice.
 *
 * The player with the highest hand value is the winner. Note that hand
 * values can be equal in which case you have a tie.
 *
 * @param cards The cards to get the value for in 'specific' representation.
 * @param initial_val The initial value to help speed up the calculation.
 * @return The evaluated value.
 */
int get_handvalue(std::span<int const> cards, int initial_val)
{
    int p = initial_val;
    for (auto const& c: cards)
        p = HANDRANKS[p + c];
  return p;
}


std::pair<Strategy, Strategy> get_nash(int num_iterations,
    int sb_size, int bb_size, int stack_size)
{
  load_handranks("D:\\Code\\poker\\Evaluator\\handranks.dat"); 

  // Initialize players' strategies
  // note that these won't necessarily converge to the nash equilibrium
  // it's the average that will converge to nash equilibrium
  // initialize strategies to be coinflip whether to go all in
  Strategy btn_strategy = Strategy(0.5);
  Strategy bb_strategy = Strategy(0.5);
  
  // At the end, each array entry will be divided by the number of
  // times the particular starting hand was dealt to get the the
  // Nash Equilibrium strategy.
  //  why a double?
  std::array<std::array<double,13>,13> btn_strategy_sum = { 0 };
  std::array<std::array<double,13>,13> bb_strategy_sum = { 0 };
  
  // keep track of the number of times a hand was randomly dealt to
  // a particular player
  std::array<std::array<unsigned int,13>,13> btn_hand_count = { 0 };
  std::array<std::array<unsigned int,13>,13> bb_hand_count = { 0 };
  
  //  13x13x2 3D-array for the sum of regrets of each action (push/fold for
  //  the button and call/fold for the big blind) for every
  //  hand in chart format
  //  std::array is hard to read so use long long [][][]
  long long btn_regrets_sum[13][13][2] = { 0 };
  long long bb_regrets_sum[13][13][2] = { 0 };

  // apparently it's bad practice to declare outside of loop
  // doing this for performance reasons
  // mersenne twister pseudo random number generator
  std::mt19937_64 prng;
  prng.seed(std::random_device{}());

  // randomizers to decide actions
  std::uniform_real_distribution<double> distribution1(0.0, 1.0);
  std::uniform_real_distribution<double> distribution2(0.0, 1.0);

  // The random numbers used to decide actions
  // Each strategy entry in btn_strategy and bb_strategy arrays
  // is a probability. if r1 is less
  // that that probability, button will push. If button pushed, then
  // if r2 less than the strategy then call button's push.
  double r1, r2;

  //deck of cards
  std::array<int,52> deck;
  std::iota(deck.begin(), deck.end(), 1);

  std::array<int,2> hand1, hand2, btn_hand, bb_hand;
  std::array<int,5> board;

  int board_val, hand1_val, hand2_val, btn_val, bb_val;
  Action btn_action, bb_action;

  std::pair<int,int> index1, index2, btn_index, bb_index;


  // Utilities (utility is a game theory term) for each action
  int btn_push_util, btn_fold_util, bb_push_util, bb_fold_util;
  int btn_regret, bb_regret;
  //norm is just sum of regrets summed over each potential action for particular hand
  long long btn_norm, bb_norm;


  for (int i = 0; i < num_iterations; i++)
  {
    // Shuffle using something similar to Fisher-Yates algorithm
    // except stopped after 9 cards
    // instead of shuffling the entire deck.
    // This reduces the runtime by a noticeable amount.
    // e.g. using std::shuffle is very slow
    // 9 = 5 board cards + 2 cards from each player
    for (int j = 0; j < 9; j++)
    {
        std::uniform_int_distribution<> shuffle_distrib(j,52-1);
        std::swap(deck[j], deck[shuffle_distrib(prng)]);
    }

    hand1 = {deck[0], deck[1]};
    hand2 = {deck[2], deck[3]};
    board = {deck[4], deck[5], deck[6], deck[7], deck[8]};

    // determine value of each hand dealt
    board_val = get_handvalue(board);
    hand1_val = get_handvalue(hand1, board_val);
    hand2_val = get_handvalue(hand2, board_val);

    index1 = get_index(hand1);
    index2 = get_index(hand2);
    
    btn_hand = hand1;
    bb_hand = hand2;
    btn_val = hand1_val;
    bb_val = hand2_val;
    btn_index = index1;
    bb_index = index2;
      
    // Swap the starting hands between the players and keep the board the
    // same to simulate another round of play to reuse the p-values that
    // have already been // looked up from the HANDRANKS.dat array. This
    // essentially cuts the runtime in half.
    // NOTE: total number of hands played will be 2 * num_iterations
    for (int j = 0; j < 2; j++)
    {
      if (j == 1)
      {
        btn_hand = hand2;
        bb_hand = hand1;
        btn_val = hand2_val;
        bb_val = hand1_val;
        btn_index = index2;
        bb_index = index1;
      }

      // button's hand outcome. either WIN, LOSS, TIE from above
      Outcome hand_outcome;
      if (btn_val > bb_val)
        hand_outcome = Outcome::WIN;
      else if (btn_val < bb_val)
        hand_outcome = Outcome::LOSE;
      else
        hand_outcome = Outcome::TIE;


      // get (randomized) actions using probability distributions
      r1 = distribution1(prng);
      if (r1 < btn_strategy.get_strategy(btn_index.first, btn_index.second))
        btn_action = Action::PUSH;
      else
        btn_action = Action::FOLD;
          
      r2 = distribution2(prng);
      if (r2 < bb_strategy.get_strategy(bb_index.first, bb_index.second))
        bb_action = Action::PUSH;
      else
        bb_action = Action::FOLD;

      // determine button's utility (game theory lingo)
      if (bb_action == Action::PUSH)
      {
        if (hand_outcome == Outcome::WIN)
          btn_push_util = stack_size;
        else if (hand_outcome == Outcome::LOSE)
          btn_push_util = -stack_size;
        else
          btn_push_util = 0;
      }
      else
      {
        btn_push_util = bb_size;
      }

      // calculate regret of NOT choosing other action
      btn_regret = 0;
      btn_fold_util = -sb_size;
      if  (btn_action == Action::PUSH)
        btn_regret = btn_fold_util - btn_push_util;
      else
        btn_regret = btn_push_util - btn_fold_util;

      //bb regret of not choosing other action
      bb_regret = 0;
      if (btn_action == Action::FOLD)
        bb_regret = 0;
      else if (btn_action == Action::PUSH)
      {
        // bb push utility
        // only relevant if both players don't fold
        bb_push_util = 0;
        if (hand_outcome == Outcome::WIN) //means btn won which means bb lost
          bb_push_util = -stack_size;
        else if (hand_outcome == Outcome::LOSE)
          bb_push_util = stack_size;
        else
          bb_push_util = 0;

        bb_fold_util = -bb_size;

        if (bb_action == Action::FOLD)
          bb_regret = bb_push_util - bb_fold_util;
        else
          bb_regret = bb_fold_util - bb_push_util;
      }
      
      // add regrets to cumulative regrets array
      if (btn_action == Action::PUSH)
        btn_regrets_sum[btn_index.first][btn_index.second][1] += btn_regret;
      else
        btn_regrets_sum[btn_index.first][btn_index.second][0] += btn_regret;

      if (bb_action == Action::PUSH)
        bb_regrets_sum[bb_index.first][bb_index.second][1] += bb_regret;
      else
        bb_regrets_sum[bb_index.first][bb_index.second][0] += bb_regret;
          
          
      // calculate btn normalization sum
      // which is just the sum of regrets summed over each potential action
      // see Rock Paper Scissors example in Neller, Lanctot paper
      btn_norm = 0;
      for (int k = 0; k < NUM_ACTIONS; k++)
      {
        if (btn_regrets_sum[btn_index.first][btn_index.second][k] > 0)
          btn_norm += btn_regrets_sum[btn_index.first][btn_index.second][k];
      }
          
      // update btn strategy
      // regret doesnt measure how much you regret the action, it measures
      // how much you regret NOT taking that action when you chose other
      // actions
      if (btn_norm > 0)
      {
        if (btn_regrets_sum[btn_index.first][btn_index.second][0] > 0)
        { 
          btn_strategy.set_strategy(btn_index.first, btn_index.second, 
              btn_regrets_sum[btn_index.first][btn_index.second][0] /
              (double) btn_norm);
        }
        else
        {
          btn_strategy.set_strategy(btn_index.first, btn_index.second, 0);
        }
      }
      else
      {
        btn_strategy.set_strategy(btn_index.first,
            btn_index.second, 1.0 / NUM_ACTIONS);
      }
          
      // calculate bb normalization sum
      bb_norm = 0;
      for (int k = 0; k < NUM_ACTIONS; k++)
      {
        if (bb_regrets_sum[bb_index.first][bb_index.second][k] > 0)
        {
          bb_norm += bb_regrets_sum[bb_index.first][bb_index.second][k];
        }
      }
          
      // update big blind strategy
      if (bb_norm > 0)
      {
        if (bb_regrets_sum[bb_index.first][bb_index.second][0] > 0)
        { 
          bb_strategy.set_strategy(bb_index.first, bb_index.second, 
              bb_regrets_sum[bb_index.first][bb_index.second][0] /
              (double) bb_norm);
        }
        else
        {
          bb_strategy.set_strategy(bb_index.first, bb_index.second, 0);
        }
      }
      else
      {
        bb_strategy.set_strategy(bb_index.first, bb_index.second,
            1.0 / NUM_ACTIONS);
      }


      //update strategy sums
      btn_strategy_sum[btn_index.first][btn_index.second] +=
        btn_strategy.get_strategy(btn_index.first, btn_index.second);
      bb_strategy_sum[bb_index.first][bb_index.second] +=
        bb_strategy.get_strategy(bb_index.first, bb_index.second);
      
      // count how many times a starting hand was played
      btn_hand_count[btn_index.first][btn_index.second] += 1;
      bb_hand_count[bb_index.first][bb_index.second] += 1;
    }
  }    
  
  // Once a sufficient number of hands have been simulated, 
  // you can take the average over total number of hands for
  // each potential starting hand to get the average strategy which has
  // hopefully converged to a Nash Equilibrium. The Nash Equilibrium is
  // not just one strategy (e.g. the button's strategy) but both strategies
  // together form the Nash Equilibrium. The solution can be tested against
  // another strategy using headsup_sims.cpp
  Strategy ave_btn_strategy, ave_bb_strategy;
  for (int i = 0; i < 13; i++)
  {
    for (int j = 0; j < 13; j++)
    {
      ave_btn_strategy.set_strategy(i, j,
          btn_strategy_sum[i][j] /btn_hand_count[i][j]);
      ave_bb_strategy.set_strategy(i, j,
          bb_strategy_sum[i][j] / bb_hand_count[i][j]);
    }
  }

  return std::make_pair(ave_btn_strategy, ave_bb_strategy);
}


int main(int argc, char* argv [])
{
  int num_iterations;
  if (argc == 2)
  {
    num_iterations = std::stoi(argv[1]);
  }
  else
  {
    num_iterations = 100000;
  }

  int small_blind = 1;
  int big_blind = 2;
  int stack_size = 20;

  std::pair<Strategy, Strategy> strats = get_nash(num_iterations,
     small_blind, big_blind, stack_size);

  std::cout << "Button Strategy:" << std::endl;
  strats.first.print();
  std::cout << std::endl;
  std::cout << "Big blind Strategy:" << std::endl;
  strats.second.print();
  std::cout << std::endl;
  std::cout << "iterations: " << num_iterations << std::endl;
  std::cout << "blinds: " << small_blind << "/" << big_blind << std::endl;
  std::cout << "stack size (in chips): " << stack_size << std::endl;
  std::cout << "Note: Unsuited in bottom left, suited in top right."
            << std::endl;

  return 0;
}
